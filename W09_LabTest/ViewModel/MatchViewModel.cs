using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using W09_LabTest.Model;
using W09_LabTest.Repository;

namespace W09_LabTest.ViewModel
{
	partial class MatchViewModel : ObservableObject
	{
        private Match _matchData;
		public Match MatchData => _matchData;

		//Match Name
		[ObservableProperty]
        private string _matchName;

        //Maps
        //Required: SelectedMap, AvailableMaps
        [ObservableProperty]
        private Map _selectedMap;

        [ObservableProperty] 
        private List<Map> _availableMaps;

        //Legends
        //Required: SelectedLegend, AvailableLegends, MatchLegends
        // remark: always use the public property to notify WPF
        [ObservableProperty]
        private Legend? _selectedLegend;

        [ObservableProperty]
        private ObservableCollection<Legend> _availableLegends;

        [ObservableProperty]
        private ObservableCollection<Legend> _matchLegends;

		public MatchViewModel(Match match, ApexLegendsRepository apexRepository)
		{
            _matchData = match;

            //Sync Name
            MatchName = _matchData.Name;
            
            //TODO: Get All maps from the ApexRepository
            AvailableMaps = apexRepository.GetAllMaps().ToList();
            //TODO: Set the default map (or the one already in the 'match' object)
            SelectedMap = AvailableMaps.Find(map => map.Id == MatchData.MapId) ?? AvailableMaps.First();


            //TODO: Get all Legends from the ApexRepository
            var legends = new ObservableCollection<Legend>(apexRepository.GetAllLegends());
            //TODO: Sync the match legends and available legends to the data in the match object.
            //Available legends = All legends without Match Legends
            AvailableLegends = new ObservableCollection<Legend>(legends.Where(l => !MatchData.LegendIds.Contains(l.Id)));
            SelectedLegend = AvailableLegends.FirstOrDefault();
            MatchLegends = new ObservableCollection<Legend>(legends.Where(l => MatchData.LegendIds.Contains(l.Id)));

		}

        //Hooks (Generated by MVVM Community Toolkit)
        partial void OnMatchNameChanging(string value)
        {
            //Sync match name in _matchData model class
            _matchData.Name = value;
        }

        //TODO: Add Selected Map Changed Hook...
        partial void OnSelectedMapChanged(Map value)
        {
			_matchData.MapId = value.Id;
        }

        //Commands
        [RelayCommand]
        void AddLegend(Legend? legend)
		{
			if (legend == null) return;

            //TODO: Add legend to match legends list
            MatchLegends.Add(legend);
            
            //TODO: Remove legend from available legends
            AvailableLegends.Remove(legend);

            //TODO: Update selected legend (e.g., first available legend)
            SelectedLegend = AvailableLegends.FirstOrDefault();
            
            //TODO: Update _matchData (Add legendId to legend's list)
            MatchData.LegendIds.Add(legend.Id);
		}

        [RelayCommand]
		void RemoveLegend(Legend? legend)
		{
			if (legend == null) return;

            //TODO: Remove legend from match legends
            MatchLegends.Remove(legend);

            //TODO: Add legend to available legends
            AvailableLegends.Add(legend);

            //TODO: Update _matchData (Remove legendId from legend's list)
            MatchData.LegendIds.Remove(legend.Id);
		}
	}
}
